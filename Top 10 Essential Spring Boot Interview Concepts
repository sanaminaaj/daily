00:00:00	hi guys this video is all about top 10 topics according to me springel interview prep top 10 topics according to me spring Concepts hi guys in this video we will discuss what is happening internally in the run method sometimes interviewer might ask you how spring boot Works internally because if you see this is only one line which is starting your spring boot application so as a springbot developer you should be aware like what is happening so if I will go inside this run uh method of the spring

00:01:07	application. class and then you will see here so let's try to find what is the main method so this is the main method of run and if you see we have like around 30 to 40 lines of code and inside that we have different methods so as a springboard developer even if you don't know too much in deep but you should able to tell the interviewer the high level steps which are happening in the run method so we will check that out so first is stopwatch so this is just to start the timer so that you are aware

00:01:38	the spring boot application started in 1 second or 2 second right or 3 second just to track how much time it took to start the application and then after that it is doing configure headless property because we don't need any display device to run the spring boot application so that's why we are doing configure headless property and then after that what is happening if you see whatever arguments we are passing from the command line it is picking up that arguments and based on that arguments and based on the

00:02:10	environment properties if you are aware of spring profiling concept we have like uh different profile spring can manage based on environment whether it's a Dev environment or test environment right so all that things is happening in this step and after that you would have seen the banner gets printed whenever we run the springboard application right uh so after that the main step is this one because here it is creating the application context and if I go inside this you will see they have switch

00:02:39	statement based on two case one is either your application context can be seret and either it can be reactive so how it is deciding so internally it will check if you have springut starter web dependency so if I go to pom.xml so we are using this spring boot starter web we are not using reactive dependency here right so based on that this project will be considered as seret web application but if you're using all reactive things then it will be reactive web application so once a user finds what is

00:03:11	your application context it will do prepare context and refresh context based on all the things like context environment arguments and in the refresh context whatever controllers you have whatever components you have whatever dependencies beans whatever you have written in your spring boat which you want spring inut to load at runtime on the all the beans configurations components right so all these things are happening at this step and after that stopwatch do stop so if I go to terminal here so let's say if I will run this one

00:03:50	M springboat run so the run method is being called so if you see here this Banner this was the banner which I was talking about which is happening and if you see here the stopwatch will start and then in the last you should be aware that this application started in how many seconds right so all that things are happening and then it is using web application context based on the dependency in the P XML and then if you see this is the profiles which is being set to default and we are not sending anything in the uh argument list so it

00:04:22	is taking Port as 8080 because it's a default Port right so all that things are happening again we don't have to be aware of very deep but even if you explain the things which I explain to you now at the high level steps you would be good for this portion hi guys in this video we will discuss how to apply validation to the post mapping basically same concept can be used for get mapping or put mapping but sometimes interviewer can ask you like if you have some post method let's say register user and inside this the

00:04:55	user is passing you some object in the request body and now you have to apply some validations and then you have to register that user in the database so what you will do so so one Legacy way of doing is like we do in Java like if user dot get age is not equal to 18 for example right so this is very Legacy way of doing it and you have to do lot of IFL statement on all the fields and apply validations so instead of doing all these if else in Spring boot we have one dependency which is known as spring

00:05:26	boot starter validation which is really helpful to automate all these validation process so what I will do is let's say the user is getting passed to the request body then I will go to the request I will go to the user class here you will see I have used some of the annotations which are coming from Spring boot starter validation and here what I am doing is I am saying name should not be blank I'm using not blank annotation and saying if it's blank right send this message to the consumer and then I'm

00:05:56	also applying size their name should be minimum of two character if not then message should be returned like this so if you think from the Java perspective if I have to do same thing by using IF else then how you will do I have to write here if user do get name dot length is not is less than two for example just I'm giving example so you have to do lot of IFL statement so instead of doing that you can directly use these annotation and here can also pass maximum length let's say the name should not be greater than 20 and then

00:06:35	the message can be name should be between two and 20 characters right and name is mandatory same thing for age you can play with the validation you can set minimum age as 18 if it's less than 18 then you show this message and for email you don't have to do lot of regular expression right because if you see if you think if you know the regular expression concept you know like in Java we will get the email and see the format is correct via regular Expressions but here you can simply use this email tag it will take

00:07:12	care of the format is correct or not so now if I will run this application and before running I want to show this code which I have written in the global exception handle because if you see here more than one validations can fail and in the global exception Handler what I am doing is I am binding all the errors and I am doing for each Loop and sending as a bad request so if I will run this application and if you see here if I am passing everything correct here and if I will click on send user registered

00:07:42	successfully if I pass age as 15 you will see if you see here right even if you put all that tags still the validation is not working because one of the tag is very important which you have to put on post mapping so here if you see we have not given instruction to the input that you should validate this body so to do that we have to use valid tag so this annotation is very important so what will happen even if you use all these validations in your user class but you are not using this valid annotation

00:08:14	then no validation will be applied on the request body so now if I will run this uh code I will do Mayan springbot run and then if I will go here now if I am passing the age S15 you will see age should not be less than 18 and we only have one error but let's say if I pass name as only a then if you see here we will get a two errors here saying that name should be between two and 20 characters and if I pass some aman.com which is not a valid email format then it should give email should be valid and

00:08:50	if I pass everything correct all the validations will pass and then if I will trigger the request the user will get registered successfully so this is is very important and very efficient way of doing validations on the request body but the same concept again you can use on any of the mapping like get mapping put mapping the only thing interviewer want to see is you are aware of the springo starter validation dependency and how you can use it so the best example is for post mapping but again it

00:09:21	can be leveraged in any of the mappings uh in your spring boot code I just downloaded the project from spring.io the people who are new to springboard they can go to this website select MAV Java version and there they can add dependencies so let's jump into code so here what I have done is I have created one database config file and I have used this configuration annotation and inside this I have used this value annotation to fetch these values from the properties file so if you see I have like db. server name and then I have db.

00:10:01	username then I have db. server password right so these four properties and then Getters and Setters Yeah so basically what will happen is value annotation will try to find this property in the properties file and in the resource folder and we give the value at uh runtime right so if I go to the actual code I have one URL here database config and here if you will see we are fetching all the four properties with the help of getter method so basically what it will do it will get the value from this class and this class

00:10:34	will fetch the value from properties file okay so we have here in the properties file if you see db. server name username server password server so if I will run this code right so you will see like it's working fine so the flow is like when the starting point will be we will hit this URL this URL will go to the getter method of database config and getter method will fetch the value of this which is coming from our application default. properties this value so if I go to Local Host and you will see we are getting server we are

00:11:10	getting username password and so if you have noticed like the name of this property here right is not matching exactly with this properties mentioned in the properties file right because of the relaxed binding concept so what spring boot does is for each of the property mentioned here right for example server name so it will try to find server word name in the four cases so first one is like so this one is camel case right and then server name it is in the Kabab case and then server uncore name which is snake case and then

00:11:47	all caps but snake case server right caps so if you see here also I have mentioned server name in camel case username in Kebab case server password password in snake case and server port in caps right so what spring boot will do at runtime is it will try to find the property right which is mentioned in this value annotation in these four cases so which is known as relaxed binding concept so if interviewer will ask you you can explain it like it works for these four cases camel Kebab snake and cap case right and you can describe

00:12:26	the flow which we discuss now so this is about relaxed mind which is better Properties or EML so if you see here by default spring boot works with properties file and in the properties file we are uh giving the properties like this but if you see we have like lot of repetition in this right like DB dot is repeating because there is no hierarchy right DB dot is repeating and in case let's say we have other properties uh user do service do URL right something value right so if you see the reputation keeps on

00:13:03	increasing right I have to give this text so many times like based on number of properties that service have and then maybe user dot then other property can be there right so if you see the repetition keeps on increasing and code readability is not that great here in my opinion uh but if I go to the EML file which I created so I just clicked on resources right click new file and application so what I did here is if you see it's a the yl file so it's a markup language so in this you can describe the

00:13:34	hierarchy of the properties so it's more readable right so whenever I so as soon as I see this file I know like these properties belong to DB these properties belong to servers and these are the two ways in which you can also maintain the list right so servers is a list and it have two values and this is also like a list of array right uh so these are the ways you can use and it is a markup language so it have like lot of benefits so I will not go into detail like all the benefits of EML because our

00:14:06	interview question is basly between properties versus EML so you can say to interviewer like EML you prefer EML because of the human readability and the less repetition of the code and the best part is it offers hierarchy which is like human readable and it is less error prom right so all that answers you can give to interviewer so I will just Mo so what I will do here is and if you want to impress interviewer more right so you can also say like application DOL is not like by default activated in springbot so if I

00:14:42	have to read from this right application EML so I have to use here additional tag here so let's say I have to use enable configuration properties and then I have to use this in the main file if you see here we have to use property source and class path I have G given giving like please fetch the values from this file right so if I will go to this file it is EML right so I will change to EML TP so we know like it's getting fetched from here so now if I will run this code right so you will see it should pick up

00:15:14	from the EML file so it's running so once it's this is just like if you will give this answer like in detail right instead of just explaining about readability and hierarchy you will really put a very good impression on the interview so if I will go here and if I will run this we miss some one tag so if you see it's still not picking from the EML file right so if I go here database config so I think we have to here give configuration properties okay so now if I will run this so hopefully it should run now so

00:15:50	we have added like enable configuration properties and then configuration properties here and if I will go there now so if you will see it is coming from the emlp so you can give this answer to interviewer like we have to add these properties and then in the main file you have to add this property source to pick from application. EML we need spring profiles so if you see here right I have like three application. properties file right so basically these are because your properties will differ in your local or

00:16:25	Dev environment and then test environment and then production right so that's why spring offers you the uh profiling concept so you can have different properties file and inside each property you can have the values based on that environment let me run this code so it will be more clear to you guys so what I will do I will just remove that tags here or I will just comment it so we will use the properties file in this case so I will let me comment and then in the main file so I will comment this line right so it will

00:16:57	start picking up from application default so if you see if we like without any profile right it is always picking up from the application default properties and then now let's try to pass the profile as Brad so we will able to validate if it's picking up from the prod file so I will go here and I will use command to pass the profiles is equal to prod here okay so spring boot. run. profile so this can be set up in your genkins or whenever your code is deploying in any of the platform so if I will run this now so you will able to

00:17:31	see like instead of default DB the pro DB should start coming when we hit that URL so it's running fine now so I will go here so you see the prod DB is coming so what happened here is like we gave it profile as prod so spring boot searched for application hyphen profile name which is prod and it picked up this properties right so this is how spring profiling works and also in your project you would have seen like there is also like application do properties file right so what happened in this case is

00:18:03	like how spring boot works is uh for example let's say from this properties I will copy this so based on the profile it actually create application. properties file okay in the background so what I will do let's say application dopr so I will I will just put one property here from here to properties here right and I will give it as let's say 9090 right so what will happen now is when as soon as I gave prod right profile so it will append these four properties or let's say so for example so I will mention this property

00:18:47	in the prod also so that it the scenario will be clear so now what will happen like these all four properties will be copied in this one and if you see this property is duplicated right so it will fetch the value which is present in the application PR so it will override this value right so let's see if it works now so that because that means the default value is 80 80 but if in case any of these properties file based on the profile is having any value it will override the value and pick up the value

00:19:21	from that file so I think it's getting confusing so let's run the code so in this case we have 9090 here so I will change it to 8080 and we have 90 90 here okay so what should happen now is so as soon as we hit the code right it should pick up 8080 it should not pick up a 9090 okay now let's run the code again so if you see here so in the application prod properties our port number is 8080 right so if I will hit this it's coming 8080 right so now if I will call the test one so I will remove this and in the test one I will remove

00:20:08	this one right for example I removed there is no port number in our test so what will happen is it should pick up 9090 so now if I will pass the test profile right so you will see that the port number is coming from server port and 9090 so if I will go here so you see test TB is coming and port number is coming 9090 so that's how it works so it's not mandatory to have application. properties but in case you want like some of the properties you want to mention by default here right and in case if it's mentioned in any of the

00:20:41	profile property then it will value will get overr so what I have did is I have created one file scheduled task example and here what I have used configuration annotation and then I have used enable scheduling annotation so this annotation is very important without this even if you have scheduled method inside but if you miss to give this annotation right your scheduler will not run so that's why you have to be very careful uh while writing the scheduled methods because you might miss this and it will not run

00:21:21	right so first thing you can always tell to your interviewer like if we need to have schedulers in our Spring Book this annotation is very important which is known as enable scheduling and here I'm simply creating one function so public void schedule task fixed DeLay So if you see here we are using here fixed delay is equal to 1,00 millisecond so which is equal to 1 second right so what I'm saying is I want to run this method so you can put any logic right in production uh you might want to send

00:21:55	some logs every second or you might want to send logs every hour to other system or you want to you know send some data every hour or every day to other system so there are a lot of production use cases so there are lot of schedulers uh so myself also I have worked on lot of schedulers because most of the production applications you want to you know combine the data and send the data to other systems at fixed interval or maybe in over the weekends also and everyday batch also right so there are

00:22:25	lot of use cases in production that's why these schedulers if you're working on any a production application uh so you have to use the scheduled methods there for any use case so there are a lot of use cases so in this case what I'm seeing is fixed delay is 1 second so it should run every 1 second right just for this example but in production it can be 1 hour 30 minutes or anything so now the same method I've created is with the fixed rate of 1 second right so interviewer might ask you like this all

00:22:59	looks same right only difference is fixed delay and fixed rate right so fixed delay you want to use when you want to track the previous execution also and you don't want to run this logic in multiple threads so what I mean is like let's say the first instance run with the fixed delay right but this task took two two seconds so this fixed delay will start after the task is finished so if I say here so what I mean by that is let's say task a started it started at let's say 10th second and it took 5

00:23:36	Second right so that means it got finished at 15th second right so task B will start after 15th plus whatever the parameter is there of fixed delay in this case one right so it will start at 16th second not at 11th second right because 10th second was the start of the task a 15th second was end of task a so task B will start 15 plus whatever fixed delay is there so with the help of fixed delay right there will be never a case two threads are running it in parallel okay so that's why you want to use the fixed

00:24:17	delay in the scenarios let's say you are processing some customer data right and you don't want to process or start a new instance of a scheduler until the previous instance instance is working right so that's how you can work with fixed delay but with the fixed rate right fixed rate will not track your previous executions so in this case if I take a same example here so what will happen is Task a so task B will start at 11 second right and task uh c will start at 12th so that means task B doesn't

00:24:51	care about if task a is still executing or not it will simply use this parameter and run this logic after every 1 second okay so this is main difference between fixed delay and fixed rate and for fixed rate you can use the this fixed rate like if I have to push some logs or where I have to push you know some other files and it doesn't matter if previous instance is running right so in that case you can use fixed rate okay so now if I will run this right so let's run so I will say may one spring boot

00:25:26	run so you will see the both task will work right so fixed rate is working fixed delay is working fixed rate fixed delay right so now let's take an example of fixed rate right so we we said that and this is very important concept so let's say if I put here thread. sleep right and I put three seconds and I will just put a try catch uh exception Handler here so now according to our logical or theoretical explanation right so task a will run let's say 10 second it will take 3 second because we have put fed do

00:26:05	sleep right and then it will finish at 13 second but other task should run after 11 after 1 second each right but it will not happen by default so if I will show you this and let me comment this one or let me increase the time rate so we can see the example of a fixed rate whether it is running every second or it is is waiting because of the thread dot Sate so you will see here so fixed delay task fixed rate task work 780 right but it didn't work at 781 it next instance executed at 83 86 86 so that

00:26:47	means it is still waiting right this is happening because spring boot by default use only one thread okay so that's why there is no more thread so that's why we have to use one more annotation here which is known as async annotation so that's what you can tell to your interviewer also which will give a really good expression so now if I will run the same right uh program uh so you will see it's not waiting for this uh task so it will immediately run after every 10 11 12 13 14 even if each task is taking 3 second it doesn't care so

00:27:22	with the help of async you can really achieve that behavior of fixed rate so this is how it works in chrone expression we have if you see the six uh attributes here right so what does that mean is first one is seconds second one is minutes third one is hours this one is day of month this is month and this is day of week right the star means the all instance so that means this task will run on all days and on all months right and question marks mean any day of week right so that's how it works so that means this method will run

00:28:02	every day at 9:53 p.m. so if I will see my current time right it's 3:10 p.m. right uh so I will say 15 and I will say here 11 right so that means if I will run this program it should run now this task so that's what this chrone expression means so if you see our fixed delay task ran our fixed rate task is running every second for this example and as soon as the 311 will come right uh in some seconds this method will be picked up and it will run so if you see here the Chone task right so as soon as it's 3:11 p.m. here the

00:28:37	chrone task ran so that's how you can use chrone expression so a lot of Chone expression generator so I'm using Java in/ Chone so because it will tell me the last execution and next execution also so if you see here uh like at 1511 it should run every day so if you see 19th 20th so now let's try to change some parameters so start this is our day of month right and this is our month so let's say if I want only to run my batch let's say in December right uh just an example so what will happen here is so

00:29:10	this batch will run at 1511 in December month right so that's how it works so if you see here the next execution will start from the 1st December so and also you can change let's say if I will say not and in December if you only want to run you know on weekends let's say just an example so I can say here Saturday Saturday Sunday here then you have to change this to any so now if you will see it will run in December every day between Saturday and Sunday right so that's how you can do so if I will say

00:29:45	here star so that means it will run every day whole year between Saturday and Sunday on this and if you want to give specific second you can play with it and there are lot of scenarios basically you can play with these six attributes and create your own Chone expression whatever use case so mostly in production the use case can be product on weekend you want to run or use case can be specific month also like based on holidays and all you can use Zone also because in some of the production scenario you want time zone

00:30:15	like MST or something right so you can use Zone also and then you can also fetch this Chone expression from application. config right in the last video we discussed about environment variables so you can do that with the Chone expression instead of coding here you can directly you know fetch from the application file and so that it will be easier for you to change in the future right so you can always uh mention it in the application file so here if you see I have mentioned it here so it will pick it from here and

00:30:46	run it and in the future if you want to change you can change it just here it will be changed in all the places wherever you are passing the Chone not expression so let's first understand little bit uh concept of aop like why we need aop and what are the different terms which are being used when we talk about aop so aop is aspect oriented programming and why it is used it is used to modularize the Cross cutting concerns because let's say if you have very big application right so you know like some of the functionalities like

00:31:20	logging security transactions right they are common functionalities right uh if even if you have let's say 50s of or hundreds of controllers right uh so for all of them you have to do logging right and at application Level you have to do security and transactions and many other scenarios right which can be modularized or separated from the core application logic so you don't have to rewrite every time and then if you have to change something right then you have to change at hundreds of places so to avoid all

00:31:50	that things in most of the projects uh they use aop so when we talk about aop uh so you have to understand these three terms first so advice right so advice can be either before it can be either after returning it can be after throwing it can be around so these four advices are available so basically with help of advice spring boot will know like when to execute this logic right because there should be something we have to tell right a spring boot uh like like run my logic before running this method

00:32:26	or after running this method or during running this method or if exception is coming in the method right so these four advices we can give to Spring boot with this tags right before means this will run before execution of the program after returning means once the method execution is completed after throwing is if any method throws some error or exceptions and around means before and after both so basically around the method so second thing if you see here right so one thing is this is advice so you have to really

00:33:00	understand this carefully and whatever you see here right so this is basically an expression which we call as point cut okay so it is a point cut so with the help of point cut expression so in this example I'm telling the spring boot when any method or any class within this package gets executed then before execution of that method run this logic so you can say let's say if you have 100 of controller and you want to print some statement right before execution so you can use this one line and it will be

00:33:32	implemented or it will be triggered whenever any call is being happened on any of the apis present in the controller right so if I break down this one right this part is also very important so if you see here right so this wild card means any return type because I want to implement on all the methods and classes that's why I am saying I don't care about return type so that's why I'm giving this wild card here okay and then this is my package name here this is my package name so this part right so this part specify any

00:34:07	class and any method within this package so I am saying any return type any class any method and any number of arguments so these four things you have to take care and you can modify based on the use case let's say if you have hundreds of controllers right so you want to apply on specific controllers which have specific return type I'm just giving example so that's why you can manipulate these four things to make your own point cut expression so that's how it works and this before means it will execute

00:34:39	before any API is getting triggered inside the controller after returning it is same we are giving point cut here and we are also printing the result so if you mention returning is equal to result right so we can also print result and the most powerful is around so after throwing a similar like uh when any exception is being thrown you can uh print exception here and around is very important because with the help of around you can calculate the execution time so in this thing what I am doing is

00:35:13	so I am saying like whenever any method call is happening right or let's say our API got triggered so I am printing the start time here and then I am using join Point dot dot so I'm using join point point do proceed which is proceeding joint point right so when this line will be triggered method API logic will work and after API logic is completed I am again you know calculating the end time so which will be current time minus start time and then we can log this thing in your log send to database so this is

00:35:47	very important concept here which is very helpful if you want to you know log how much time all the API calls are taking so I will run this program add this package here spring boot starter aop this is the package you need and so you have to give this aspect tag here right on the class level so these two things if you do then it will work fine and if I go to my this package controller right so web controller is a part of my controllers and I have one API here users right and user ID so and I have empty post API also save but I

00:36:22	will just create like two three more apis dummy apis so like right and here I will just say get likes and path variable I will remove here what we will do we will just say hashmap just put so this is just a dummy thing okay likees I will just say 10 so here I'm giving thread. sleep s two and here I'm giving thread do sleep one just to see if our logging is working fine okay so now we have like uh two apis like get likes and we have get users so I will just run this method uh run this project project is running so I will

00:37:00	trigger the API now users 1 2 3 4 right so now and I will also trigger the other API so which is uh likes right so here I triggered one time this API and I triggered one time this API so now if I go to the logs right so first thing is this is our start time which we printed here in the loging around so around advice got triggered and this start time got printed and then before advice got triggered which is here and we are printing before advice here and after returning advice when the method got

00:37:42	executed successfully so after returning if you see this statement result and we are printing result here right object result result right so it is also giving us the Json here so if you see name John ID 1 2 3 4 right and then with the help of this line the method got executed right and then if you see with the help of this line we were able to print like executed in 1 6 millisecond because we have threat sleep of 1 second right so 1,00 plus 6 millisecond it took so a total time it took is 106 millisecond

00:38:16	and this is our path of the API which got triggered and same thing happened for second API same thing here is our Json likes equal to 10 and we have thread do sleep of 2,000 millisecond that's why it came here 2,000 okay so in this way now once my this logic is ready right so if you see this is very small uh class just 50 to 60 lines right uh just 50 lines and even less right and if I remove all these methods and if I only need this method right so it is just a you can see just a 15 lines of method

00:38:52	but with the help of this 15 lines right no matter if I have hundred of controllers no matter how many apis I have in my controller folder now I don't have to add the code everywhere and even adding is fine but it's really a headache for developers if they want to change the logic right because let's say in future if they want to add some other logic to send this data to some other file logging database or something right then I just have to make database call here or I just have to save in file here

00:39:23	and this logic will keep work on all the controllers and I can also play with the V cards and I can also play uh you know with the advices here so this is all about aop so from the interviewer perspective the interviewer will ask you this question just to see your conceptual knowledge and even the you know system design knowledge a little bit because in this you are using like you are doing modularization and you are separating the core application logic from the uh repeated concerns or you can

00:39:54	say the concerns like logging security transactions so you're not mixing all that common concerns with the application logic so it's really good so you can tell interviewer about advice you can tell about point cut you can tell about join point and if the interviewer is giving you handson you can just create simple aspect file and you can just demo like around method which is very useful and which can be really used in lot of places and you can just uh write this 10 15 lines and show this demo whatever I saw you now show

00:40:22	you now so actuator basically gives us production ready features for example like you want to see the health check of your application so if I go to the same right so I will just say actuator here so if you see here if you see with the help of actuator right all these URLs are already ready for me so if I will trigger this URL let's say SL health and I will go here SL health so status is coming up right and if I want to see let's say all the threads for example all right so I can use the thread dump

00:41:01	method so if I will call this method so it is showing me all the threads here so we have the thread State runnable and this is very interesting information like I really find this information very interesting because I really like to play with threads so this is all you can see like your application is running but if you want internal information about threading right this is the best URL you can use thread Dum so it will give you all the things which is happening at the background okay and then if you see we

00:41:33	have other useful features here we have loggers we have environment and we have info so if I will call info so so we I not added any info in my application properties file but you can add that here and it will start coming and this is also very good beans so whatever beans are in my project right um so it will tell you and let's say we had web controller right so it will giving me the controller / web controller right so the scope is single turn all that things you can see with the bean beans also okay and these are

00:42:06	all the spring boot internal beans also which we need to run the project so the point is with the help of actuator these all are production ready codes I have not written any piece of code so it all comes with actuator package so how to add that package so you have to add in the pal. XML you have to start add springboard starter actu here and in your application. properties file you have to add this management. endpoints do web. exposure. include is equal to Star so it will include all the end points so this is about actuator so

00:42:43	with the help of these two lines one is this one and one is this package right so all the production ready features are available to us and the best part is you can also write your custom logic so if let's say you want to over some method right so you can take a help of override here and you can see component I'm giving then it is I'm using inheritance Health indicator right so in that way you can override any of that acuator and you can build custom logic here and you can uh make use of it but even if you

00:43:19	don't use custom logic most of them you can use in your application the way they are but if you want to use like inside Health sometimes you have to add livess as Readiness code right so you can also add that so this is about actuator and if interviewer will ask you can just give this example like they used uh to give us production ready features like health check is there beans is there right threads are there so all that production ready features are there which can be used to monitor our application and see the health check and

00:43:47	see the internal information of of our application thread information and it can be enabled withy and you can write this endpoint line to enable or include all the actu hi guys uh so in this video we will learn about what is the use case for primary annotation and qualifier annotation and how we can use both of them and this is also the most asked question in the springboard interviews so let's understand by coding the example so I think that's the best way to explain you this use case so let's

00:44:18	say we have one interface here right content strategy and we have one method post content so now what I will do I will say one class and I will say image content strategy and then I will implement this interface so I will Implement content strategy and whenever you are implementing the interface you have to implement or overwrite the method also right so what I will do here is I will click on Implement methods so this is how you can Implement so you see the post content right so in this you can give your any

00:44:52	implementation so let's say I will say image content strategy right now I will create the another class it's a video content strategy and it will also implements the same interface and I will just copy this method from here to here right now here I will say video content strategy so now you will see there is one interface there are two classes right image content strategy and video content strategy so now what I will do I will create one service let's say class social media service let's say right so and I will

00:45:32	use service annotation here so here I will have one Constructor with the same name social media service right which will get the content strategy right content strategy then inside this it will set the content strategy right so we will set one private final variable private final content strategy and I will give the same name here right so now you will see right I will say this do cont content strategy is equal to content strategy and now we will have let's say one public method public word post post

00:46:05	content let's say post right and it will just call do Post content so this is the method which will come from the interface which is content strategy so now try to understand the flow right so now we have one interface and now we have two classes right both are implementing the same interface now we have one service social media service and and it is also using the same interface right and here I will use Auto wire now if you see right we have two beans uh video content strategy image content strategy right so I will what I

00:46:39	will do I will use uh configuration here right and I will say class config so in the class config we will declare both the beans right uh image content strategy and video content strategy so what I will say public content strategy let's say video content strategy and then inside this we will just return a new video content strategy right and we will also use the bean annotation here so when you say Bean annotation so we will give the same name so that uh the springboard compiler knows so here like this right and I will

00:47:14	just copy paste this and I will say image content strategy here and I will use the same right so now our code is almost ready right so now we have configuration we have two beans which are qualif for Content strategy and then we have social media service which is using the content strategy right and content strategy is our interface which have post content method right so now if I go to the main method right so what I will do here is social media service right is equal to context. getet Bean right I will say

00:47:49	social media service. class right and then we will use social media service. post method right so this is how our code looks in a single file but of course again when it's a production project you will have a different folder for service you will have different folder for configuration right and then you will use a test cases to test this but here I'm directly using the application context just to show you the example right so now if I will run this program right so I just did mayavan spring Bo run here so if you see here

00:48:16	right uh the build failure is there so if you see here right application failed to start because of the ambiguity problem because social media service required a single beIN but two were found right because if you see here when we are doing the auto wired here right when we are doing autowired in the social media service they need content strategy but content strategy have two beans Here video content strategy and image content strategy right that's why this is known as ambiguity problem because springboard compiler will not

00:48:44	know right uh what be to injest right and also if you see in the logs they will also give you solution consider marking one of the beans as primary right or using qualifier to identify the bean that should be consumed right so let's see how we can resolve this with primary right so what I will say by default I will make the image content strategy as primary right so now what will happen is if case of ambiguity problem we are telling the compiler that use this Bean as a primary Bean right so now if I will run the same

00:49:13	program you will see here the spring social media service will use the image content strategy right because we are using here uh so if you see here right so our post method is running that's why that log is coming here right image content strategy now now the next question is when the qualifier annotation will come into picture so let's say I will copy this social media service right and now I will say let's say social media Service uh YouTube right now in this case right uh in this case I don't want

00:49:48	the primary image content strategy right because it will not work for the YouTube social media service right so what I need to do is I need to say that for this service the video content strategy is qualifying right so where I am doing here Auto wir right so I have to use here qualifier tag and inside this I have to qualify video content strategy in this way now what will happen is primary is image content strategy which will work for all the social media Services until or unless they will put this qualifier annotation right so in

00:50:22	that way qualifier have higher priority than primary annotation so compiler knows when this social media service YouTube is working it have to ignore primary because qualifier annotation is here so now if I go to the main method right here so if I say social media service YouTube right uh and then I will get YouTube Do class and then I will say do Post right so now if I will run the same program so you will see that for social media service class image content strategy is working but for social media

00:51:00	service YouTube video content strategy is working right so in this way you can use primary annotation you can use qualifier annotation and you can use both when there are multiple Services right so this is the use case for primary and qualifier annotation to solve the ambiguity problem in the spring boook

